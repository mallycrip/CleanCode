# 객체와 자료 구조
__객체 : 새로운 `자료 타입` 추가 시 유용, 새로운 `동작` 추가 힘듬__<br/>
__자료 구조(절차지향적) : 새로운 `동작` 추가시 유용, 새로운 `자료 타입` 추가 힘듬__

## 왜 사람들은 필드를 Private로 정의하는가?
 외부에서 변수에 의존하지 않게 만들고 싶기 때문이다.
### 그러면서 왜 `getter`, `setter`함수를 당연하게 공개할까?
 변수를 `private`로 선언하더라도 각 값마다 `getter`와 `setter`이 있으면 구현을 외부로 노출하는 셈이다.<br/>
여기에서 말하는 `getter`, `setter`은 단순하게 `필드` 하나를 `get`하고 `set`하는 부분을 말한다.<br/>a
변수와 필드 사이에 함수라는 계층을 추가해도 구현이 감추어 지는 것은 아니다. 구현을 감추기 위해서는 `추상화`가 필요하다.<br/>

### 추상화?
 다음은 어떠한 사각형에 대한 클래스이다.
```python
class Square:
    def __init__(self):
        self._width = 10
        self._height = 10
```
이 클래스에서 정보를 가져오는 방법하면 보통 `getter`을 사용하여 가져오는 방법을 생각한다.
```python
class Square:
    ...
    def get_width(self):
        return self._width
        
    def get_height(self):
        return self._height
```
하지만 위와 같은 방법은 제대로 된 `클래스`라고 하기 어렵다. 클래스는 `추상 인터페이스`를 제공해 사용자가 구현을 모른채로 자료의 핵심을 조작할 수 있어야 한다.<br/>
다음은 사각형에 대한 상태를 구체적으로 알려준다.
```python
class Square:
    ...
    def get_area(self):
        return self._width * self._height
```
가장 처음 예시와 같이 자료를 세세하게 공개하기 보다는 `추상적인 개념`으로 표현하는 방법이 좋다. <br/>
절대 `인터페이스`나 `getter`, `setter`만으로는 `추상화`가 이루어 지지는 않는다.<br/>
특히 아무 생각 없이 `getter`, `setter`을 추가하는 방법이 가장 나쁘다.

## 디미터 법칙
 `디미터 법칙`은 잘 알려진 `휴리스틱`이다. <br/>
`디미터 법칙`은 "`모듈`은 자신이 조작하는 `객체`의 속사정을 몰라야 한다" 라는 법칙 이다.<br/>
앞서 말한 것 처럼 `객체`는 `자료`를 숨기고 `함수`를 공개한다. 이는 `조회 함수`로 `내부 구조`를 공개하면 안 된다라는 의미이다.<br/>
다음은 조금더 구체화 한 예시이다.
> 클래스 C의 메서드 f은 다음과 같은 객체의 메서드만 호출해야 한다.
- 클래스 C
- f가 생성한 객체
- f 인수로 넘어온 객체
- C 인스턴스 변수에 저장된 객체

### 기차 충돌
```python
output_dir: str = ctxt.get_options().get_scratch_dir().get_absolute_path()
```
 위와 같은 코드는 객체가 마치 한 줄로 이어진 기차 처럼 보이게 한다. 즉 조잡하게 여겨진다.<br/>
이러한 코드를 `기차 충돌`(train wreck)이라 부르며 피해야 할 코드이다.<br/>
<br/>
이러한 코드는 ctxt안에 get_options()이 있음을 나타내고 get_options()안에 get_scratch_dir()이 있음을, 또 get absolute_path()가 있다는 것을 전부 공개하였다.<br/>
즉 `함수` 하나가 아는 지식이 너무 많다.
<br/>
위 코드를 다음과 같이 나누는 편이 좋다.
```python
opt = ctxt.get_options()
scratch_dir = opt.get_scratch_dir()
output_dir = scratch_dir.get_absolute_path()
```

위 방법이 사실 `디미터 법칙`을 위반할지는 객체이냐, 자료 구조이냐에 따라 달라진다.
```python 
output_dir = ctxt.options.scratch_dir.absolute_path
```
위와 같은 코드는 애초에 자료 구조 이므로 디미터 법칙을 거론할 필요가 없다.

## 잡종 구조
 객체와 자료구조의 짬뽕. 이도 저도 아니고 그냥 양쪽에서 단점만 모아논 구조이다. 쓰지 말자.

## DTO (Data Transfer Object)
 `DTO`는 `데이터베이스`에 저장된 가공되지 않은 정보를 애플리케이션 코드에서 사용할 `객체`로 변환하는 일련의 단계에서 가장 처음으로 사용하는 `구조체`이다.<br/>
 조금 더 일반적인 형태는 `Bean` 형태이다. `Bean`은 `private`변수를 `getter`, `setter`로 조작한다.<br/>
 클린 코드에서는 이를 일종의 `사이비 캡슐화`라고 여기며 이익이 없다고 한다. ~~OO 순수주의자나 만족시킨다~~.
 
### 활성 레코드
`활성 레코드`는 `DTO`의 특수한 형태이다. `공개 변수`나 `비공개 변수`에 `getter`, `setter`가 있는 `자료 구조`이나, `save`, `find`와 같은 탐색 함수도 제공한다.<br/>
`활성 레코드`는 데이터베이스 테이블이나 다른 소스에서 자료를 직접 변환한 결과이다.

문제는 `활성 레코드`에 `비즈니스 규칙 메서드`를 추가하여 이러한 `자료구조`를 `객체` 취급하는 사람이 많다. 이는 바람직 하지 않다. 이는 자료구조도아니며 객체도 아닌 `잡종 구조`이다.<br/>
`활성 레코드`는 자료 구조로 취급하자. `비즈니스 규칙 메서드`를 사용하는 객체는 따로 만든다.

## Conclusion
`객체`는 `동작(Method)`를 공개하고 `자료(Field)`를 숨긴다. 그래서 기존 `동작`을 변경하지 않으면서 새 `객체 타입(자료)`을 추가하기 쉽다. 하지만 새 `동작`을 추가하기는 어렵다.<br/>
`자료 구조`는 별 다른 동작 없이 `자료`를 노출한다. 그래서 기존 `자료 구조`에 새 `동작`을 추가하기는 쉬우나, `기존 함수`에 새 `자료 구조`를 추가하기는 어렵다.<br/>
<br/>
어떤 시스템을 구현할 때 새로운 `자료 타입`을 추가 하는 유연성이 필요하면 `객체`를 새로운 `동작`을 추가하는 유연성이 필요하다면 `자료 구조`를 사용하면 된다.
