# 함수
이 글에서는 `함수`에 관해서 다룬다.<br/><br/>
`함수`는 `프로그래밍 언어`를 이용한 조금 더 풍부하고 강력한 `언어`이다.<br/>
`함수`를 잘 만들고 다루는 것이 시스템에 대한 이야기를 잘 풀어갈 수 있을 것이다.<br/>
<br/>
다음은 `함수`를 잘 만드는 기교에 대해서 설명한다.
### 함수는 글짓기와 같다
`글짓기`를 할 때 처음에는 먼저 생각을 기록한 후 읽기 좋게 다듬는다.<br/>
`초안`은 대개 서투르고 어수선하지만 나중에는 꽤 볼만한 글이 나온다.<br/>
`함수`도 마찬가지이다.<br/>
__처음에는 `복잡`하고 `중복된 루프`도 많으나 이 서두른 코드를 천천히 다듬고 바꾼다면 `좋은 함수`가 나올 것 이다.__<br/>
__물론 `테스트코드`는 항상 통과해야 한다.__<br/>

## 최대한 작게, 하지만 명확하게
`함수`는 최대한 작게, 하지만 명확해야 한다.<br/>
얼마나 작아야 하냐면 `들여 쓰기` 수준이 1단이나 2단을 넘어서면 안 된다.<br/>
__함수는 한가지를 해야한다. 그 한 가지를 잘해야 한다. 그 한 가지만을 해야 한다.__
<br/>
### 한 가지 작업
`한가지 작업`이 뜻하는 것은 __`추상화 수준`이 하나인 단계만 수행하는 작업이다.__<br/>
\* `추상화 수준` : 얼마나 `추상적`인가. 이 `추상적`인 것을 `구현`할수록 `추상화 레벨`은 낮아진다.
```python
get_html() # 높은 추상화 수준
foo.append('\n') # 낮은 추상화 수준
```

### 함수 당 추상화 수준은 하나로
`함수`가 확실하게 `한 가지 작업`만 하려면 `함수` 내 모든 문장의 `추상화 수준`이 동일해야 한다.<br/>
한 `함수` 내에 `추상화 수준`을 섞으면 코드를 읽는 사람이 헷갈린다. 문제는 이뿐만이 아니다.<br/>
__`근본 개념`과 `세부사항`을 뒤섞기 시작하면, `함수`에 `세부사항`을 점점 추가하게 된다.__<br/>

### 한 함수 다음에는 추상화 수준이 한 단계 낮게
위에서 아래로 프로그램을 읽을수록 `함수 추상화 수준`이 낮아지도록 프로그래밍하자. 책에서는 __`내려가기 규칙`__ 이라고 부른다.<br/>
`추상화 수준`이 하나인 `함수`를 구현하기는 쉽지 않다. 하지만 `내려가기`를 이용하면 `추상화 수준`을 일관되게 유지하기 쉬울 것이다.<br/>
> 설정 페이지와 해제 페이지를 포함하려면, 설정 페이지를 포함하고, 테스트 페이지 내용을 포함하고, 해제 페이지를 포함한다.
>> 설정 페이지를 포함하려면, 슈트이면 슈트 설정 페이지를 포함한 후 일반 설정 페이지를 포함한다.<br/>
>> 슈트 설정 페이지를 포함하려면 부모 계층에서 ...<br/>
>> 부모 계층을 ... <br/>

### Switch, 긴 if else문은 자제하라
이는 하나의 일만 하기 어렵고, `중복 가능성`이 커진다.<br/>
어쩔 수 없는 경우에는 `추상팩토리`를 써서 `중복`을 피하라.

## 인수는 적게
__인수는 적을수록 가장 이상적이다. 출력 인수는 금지한다.__<br/>
`단항`은 `함수`에 질문을 던질 때 또는 `값`을 변환할 때 사용한다. `이벤트`로써도 사용할 수 있다.<br/>
```python
file_exists("my_file") # 질문을 던지는 경우
file_open("my_file") # 변환 후 반환하는 경우
```
`이항`은 가능한 `자연적인 순서`에서 사용한다. 부득이 하게 사용 시 `위험성`을 인지해야 한다.<br/>
```python
point(0, 0) # 자연적인 순서
```
`삼항`은 `이항`보다 조금 더 주의하여서 사용해야 한다.<br/>
```python
assertEquals(1.0, amount, .001)
```
`플래그 인수`는 추하다. 존재 자체만으로도 `함수`가 여러가지 일을 한다는 뜻이기 때문이다.<br/>
```python
render(True) # 플래그 인수
```
만약 `인수 객체`를 사용한다면 조금 더 좋다.<br/>
```python
make_circle(x: int, y: int, radius: int): # 인수 객체를 사용하지 않음
make_circle(center: object, radius: int): # 인수 객체 사용 
```
`가변 인수`를 `List형 인수` 하나로 취급할 수 있다.<br/>
```python
def monad(*args): # 단항 취급
def dyad(name: str, *args): # 이항 취급
```

## 부수효과는 거짓말이다
__`함수`에 직접적으로 나타나지 않는 `부수효과`는 `오류`를 일으키기 쉽다.__<br/>
```python
def check_password(user_id: str, password: str) -> bool:
    if user == "mally":
        if password == "asdf1234":
            Session.initialize() # 부수 효과
            return True
    return False
```

## 오류코드보다는 예외를
`오류코드`를 반환하는 행위는 `호출자`의 코드에서 `오류`를 해결해야 한다는 문제가 생긴다.<br/>
`예외코드`를 사용하되, 실질적인 `동작 코드`와 혼용하지 마라. __`오류 처리` 또한 한가지 작업이다.__
```python
def delete(page):
    try:
        delete_page(page)
    except:
        log_error()
        
def delete_page(page):
    # TODO
    pass
    
def log_error():
    # TODO
    pass
```

## 반복하지 마라
__`반복`은 `소프트웨어`의 모든 악의 기원이다.__

## 구조적 프로그래밍
`구조적 프로그래밍`의 목표와 규율은 공감하나, `함수`가 작다면 별 이익을 제공하지 못한다.<br/>
- Edsger Dijkstra의 구조적 프로그래밍 규율
1. `모든 블록`에 `entry`와 `exit`는 하나씩 존재해야 한다.
2. `break`이나 `continue`는 사용해선 안되며 `goto`는 절대 안된다.
