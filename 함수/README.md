# 함수
이 글에서는 함수에 관해서 다룬다.<br/><br/>
함수는 프로그래밍 언어를 이용한 조금 더 풍부하고 강력한 언어이다.<br/>
함수를 잘 만들고 다루는 것이 시스템에 대한 이야기를 잘 풀어갈 수 있을 것이다.<br/>
<br/>
다음은 함수를 잘 만드는 기교에 대해서 설명한다.
### 함수는 글짓기와 같다
글짓기를 할 때 처음에는 먼저 생각을 기록한 후 읽기 좋게 다듬는다.<br/>
초안은 대개 서투르고 어수선하지만 나중에는 꽤 볼만한 글이 나온다.<br/>
함수도 마찬가지이다.<br/>
__처음에는 복잡하고 중복된 루프도 많으나 이 서두른 코드를 천천히 다듬고 바꾼다면 좋은 함수가 나올 것 이다.__<br/>
__물론 테스트코드는 항상 통과해야 한다.__<br/>

## 최대한 작게, 하지만 명확하게
함수는 최대한 작게, 하지만 명확해야 한다.<br/>
얼마나 작아야 하냐면 들여 쓰기 수준이 1단이나 2단을 넘어서면 안 된다.<br/>
__함수는 한가지를 해야한다. 그 한 가지를 잘해야 한다. 그 한 가지만을 해야 한다.__
<br/>
### 한 가지 작업
한가지 작업이 뜻하는 것은 __추상화 수준이 하나인 단계만 수행하는 작업이다.__<br/>
\* 추상화 수준 : 얼마나 추상적인가. 이 추상적인 것을 구현할수록 추상화 레벨은 낮아진다.
```python
get_html() # 높은 추상화 수준
foo.append('\n') # 낮은 추상화 수준
```

### 함수 당 추상화 수준은 하나로
함수가 확실하게 한 가지 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 한다.<br/>
한 함수 내에 추상화 수준을 섞으면 코드를 읽는 사람이 헷갈린다. 문제는 이뿐만이 아니다.<br/>
__근본 개념과 세부사항을 뒤섞기 시작하면, 함수에 세부사항을 점점 추가하게 된다.__<br/>

### 한 함수 다음에는 추상화 수준이 한 단계 낮게
위에서 아래로 프로그램을 읽을수록 함수 추상화 수준이 낮아지도록 프로그래밍하자. 책에서는 __내려가기 규칙__ 이라고 부른다.<br/>
<br/>
추상화 수준이 하나인 함수를 구현하기는 쉽지 않다. 하지만 내려가기를 이용하면 추상화 수준을 일관되게 유지하기 쉬울 것이다.<br/>
> 설정 페이지와 해제 페이지를 포함하려면, 설정 페이지를 포함하고, 테스트 페이지 내용을 포함하고, 해제 페이지를 포함한다.
>> 설정 페이지를 포함하려면, 슈트이면 슈트 설정 페이지를 포함한 후 일반 설정 페이지를 포함한다.<br/>
>> 슈트 설정 페이지를 포함하려면 부모 계층에서 ...<br/>
>> 부모 계층을 ... <br/>

### Switch, 긴 if else문은 자제하라
이는 하나의 일만 하기 어렵고, 중복 가능성이 커진다.<br/>
어쩔 수 없는 경우에는 추상팩토리를 써서 중복을 피하라.

## 인수는 적게
__인수는 적을수록 가장 이상적이다. 출력 인수는 금지한다.__<br/>
단항을 사용할 때는 함수에 질문을 던질 때 또는 값을 변환할 때 사용한다. 이벤트로써도 사용할 수 있다.<br/>
```python
file_exists("my_file") # 질문을 던지는 경우
file_open("my_file") # 변환 후 반환하는 경우
```
이항은 가능한 자연적인 순서에서 사용한다. 부득이 하게 사용 시 위험성을 인지해야 한다.<br/>
```python
point(0, 0) # 자연적인 순서
```
삼항은 이항보다 조금 더 주의하여서 사용해야 한다.<br/>
플래그 인수는 추하다. 존재 자체만으로도 함수가 여러가지 일을 한다는 뜻이기 때문이다.<br/>
```python
render(True) # 플래그 인수
```
만약 인수 객체를 사용한다면 조금 더 좋다.<br/>
```python
make_circle(x: int, y: int, radius: int): # 인수 객체를 사용하지 않음
make_circle(center: object, radius: int): # 인수 객체 사용 
```
가변 인수를 List형 인수 하나로 취급할 수 있다.<br/>
```python
def monad(*args): # 단항 취급
def dyad(name: str, *args): # 이항 취급
```

## 부수효과는 거짓말이다
__함수에 직접적으로 나타나지 않는 부수효과는 오류를 일으키기 쉽다.__<br/>
```python
def check_password(user_id: str, password: str) -> bool:
    if user == "mally":
        if password == "asdf1234":
            Session.initialize() # 부수 효과
            return True
    return False
```

## 오류코드보다는 예외를
오류코드를 반환하는 행위는 호출자의 코드에서 오류를 해결해야 한다는 문제가 생긴다.<br/>
<br/>
예외코드를 사용하되, 실질적인 동작 코드와 혼용하지 마라. __오류 처리 또한 한가지 작업이다.__
```python
def delete(page):
    try:
        delete_page(page)
    except:
        log_error()
        
def delete_page(page):
    # TODO
    pass
    
def log_error():
    # TODO
    pass
```

## 반복하지 마라
__반복은 소프트웨어의 모든 악의 기원이다.__

## 구조적 프로그래밍
구조적 프로그래밍의 목표와 규율은 공감하나, 함수가 작다면 별 이익을 제공하지 못한다.<br/>
Edsger Dijkstra의 구조적 프로그래밍 규율
1. 모든 블록에 entry와 exit는 하나씩 존재해야 한다.
2. break이나 continue는 사용해선 안되며 goto는 절대 안된다.
3. ...
